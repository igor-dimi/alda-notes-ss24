[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures Notes - SoSe 24",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "02-intro/02-analysis.html",
    "href": "02-intro/02-analysis.html",
    "title": "1  Program Run-time Analysis",
    "section": "",
    "text": "1.1 Reccurence Relations\nConsider a very simple reccurence relation:\n\\[\n    T(n) :=\n    \\begin{cases}\n        1               & n = 1 \\\\\n        n + T(n - 1),   & n &gt; 1\n    \\end{cases}\n\\]\nWith mathematical induction we can formally show that \\(T(n)\\) is quadratic. But there is a simpler & more intuitive way:\n\\[\\begin{align*}\n    T(n) &= n + T(n - 1)            \\tag{Def $T(\\cdot)$} \\\\\n         &= n + n - 1 + T(n - 2)  \\\\\n         &= \\dots \\tag{Repeat $n - 2$ times}\\\\\n         &= n + n - 1 + \\dots + T(1) \\\\\n         &= n + n - 1 + \\dots + 1 \\tag{Def $T(1)$} \\\\\n         &= \\frac{n(n + 1)}{2} \\tag{Gauss}\\\\\n         &\\in \\mathcal{O}(n^2)\n\\end{align*}\\]\nThis method can be applied to the more complex divide-and-conquer reccurence relation from the lecture:\n\\[\n    R(n) :=\n    \\begin{cases}\n        a, &n = 1 \\\\\n        c\\dot n + d\\cdot R(\\frac{n}{b}), &n &gt; 1\n    \\end{cases}\n\\]\nApplying the above method we expand \\(R(\\cdot)\\) repetitively according to its definition until we reach the base case, rearranging terms when necessary:\n\\[\\begin{align*}\n    R(n) &= c\\cdot n + d\\cdot R(\\frac{n}{b}) \\tag{Def $R(\\cdot)$} \\\\\n         &= c\\cdot n + d\\bigl(c\\frac{n}{b} + d\\cdot R(\\frac{n}{b^2})\\bigr)  \\\\\n         &= c\\cdot n + d\\Bigl(c\\frac{n}{b} + d\\cdot \\bigl(c\\cdot \\frac{n}{b^2} + d\\cdot R(\\frac{n}{b^2})\\bigr)\\Bigr)  \\\\\n         &= c\\cdot n + d\\cdot c\\frac{n}{b} + d^2c\\frac{n}{b^2} + d^3\\cdot R(\\frac{n}{b^3}) \\tag{Rearrange} \\\\\n         &= c\\cdot n \\left(1 + \\frac{d}{b} + \\frac{d^2}{b^2}\\right) + d^3\\cdot R(\\frac{n}{b^3}) \\\\\n         &= \\dots \\tag{Repeat $k$-times} \\\\\n         &= c\\cdot n\\left(1 + \\frac{d}{b} + \\dots + \\frac{d^{k - 1}}{b^{k - 1}}\\right) + d^k \\cdot R(\\frac{n}{b^k}) \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + d^k \\cdot R(\\frac{n}{b^k}) \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + d^k \\cdot R(1) \\tag{Ass $\\frac{n}{b^k} = 1$} \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + a\\cdot d^k \\tag{Def $R(1)$}\n\\end{align*}\\]\nSee lecture slides for the complexity analysis of final expression.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Program Run-time Analysis</span>"
    ]
  },
  {
    "objectID": "02-intro/02-analysis.html#amortized-analysis",
    "href": "02-intro/02-analysis.html#amortized-analysis",
    "title": "1  Program Run-time Analysis",
    "section": "1.2 Amortized Analysis",
    "text": "1.2 Amortized Analysis",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Program Run-time Analysis</span>"
    ]
  },
  {
    "objectID": "03/01-lists.html",
    "href": "03/01-lists.html",
    "title": "2  Lists",
    "section": "",
    "text": "2.1 Sequences as Arrays and Lists\nMany terms for same thing: sequence, field, list, stack, string, file… Yes, files are simply sequences of bytes!\nthree views on lists:",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "03/01-lists.html#sequences-as-arrays-and-lists",
    "href": "03/01-lists.html#sequences-as-arrays-and-lists",
    "title": "2  Lists",
    "section": "",
    "text": "abstract: \\((2, 3, 5, 7)\\)\nfunctionality: stack, queue, etc… What operations does it support?\nrepresentation: How is the list represented in a given programming model/language/paradigm?",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "03/01-lists.html#applications-of-lists",
    "href": "03/01-lists.html#applications-of-lists",
    "title": "2  Lists",
    "section": "2.2 Applications of Lists",
    "text": "2.2 Applications of Lists\n\nStoring and processing any kinds of data\nConcrete representation of abstract data types such as: set, graph, etc…",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "03/01-lists.html#linked-and-doubly-linked-lists",
    "href": "03/01-lists.html#linked-and-doubly-linked-lists",
    "title": "2  Lists",
    "section": "2.3 Linked and Doubly Linked Lists",
    "text": "2.3 Linked and Doubly Linked Lists\n\n\n\n\nsimply linked\ndoubly linked\n\n\n\n\nlecture\nSList\nList\n\n\nc++\nstd::forward_list\nstd::list\n\n\n\nDoubly linked lists are usually simpler and require “only” double the space at most. Therefore their use is more widespread.\n\nList Items\nClass Item of T :=\n    e: T //Data item of type T\n    next: *Item //Pointer to Item\n    prev: *Item //Pointer to Item\n    invariant next-&gt;prev = this = prev-&gt;next\n\nProblem: * predeccessor of first list element? * successor of last list element?\nSolution: Dummy Item with an empty data field as follows:\n\nAdvatanges of this solution:\n\nInvariant is always satisfied\nExceptions are avoided, thus making the coding more:\n\nsimple\nreadable\nfaster\nelegant\n\n\nDisadvantages: a little more storage space.\n\n\nThe List Class\nClass List of T :=\n    dummy := (\n        Null : T\n        &dummy : *T // initially list is empty, therefore next points to the dummy itself\n        &dummy : *T // initially list is empty, therefore prev points to the dummy itself\n    ) : Item\n\n    // returns the address of the dummy, which represents the head of the list\n    Function head() : *Item :=\n        return address of dummy\n    \n    // simple access functions\n    // returns true iff list empty\n    Function is_empty() : Bool := \n        return dummy.next == dummy \n\n    // returns pointer to first Item of the list, given list is not empty\n    Function first() : *Item :=\n        assert (not is_empty())\n        return dummy.next\n    \n    // returns pointer to last Item of the list, given list is not empty\n    Function last() : *Item :=\n        assert (not is_empty())\n        return dummy.prev\n\n    /* Splice is an all-purpose tool to cut out parts from a list\n       Cut out (a, ... b) form this list and insert after t */\n    Procedure splice(a, b, t : *Item) := \n        assert (\n            b is not before a \n            and \n            t not between a and b\n        )\n        // Cut out (a, ... , b)\n        a-&gt;prev-&gt;next := b-&gt;next\n        b-&gt;next-&gt;prev := a-&gt;prev\n\n        // insert (a, ... b) after t\n        t-&gt;next-&gt;prev := b\n        b-&gt;next := t-&gt;next\n        t-&gt;next := a\n        a-&gt;prev := t\n\n    \n    // Moving items by utilising splice\n    //Move item a after item b\n    Procedure move_after(a, b: *Item) := \n        splice(a, a, b)\n    \n    // Move item a to the front of the list\n    Procedure move_to_front(a: *Item) := \n        move_after(a, dummy)\n\n    Procedure move_to_back(a: *Item) :=\n        move_after(b, last())\n\n    // Deleting items by moving them to a global freeList\n    // remove item a\n    Procedure remove(a: *Item) :=\n        move_after(b, freeList.dummy)\n    \n    // remove first item\n    Procedure pop_front() :=\n        remove(first())\n\n    //remove last item\n    Procedure pop_back() :=\n        remove(last())\n\n    // Inserting Elements\n    // Insert an item with value x after item a\n    Function insert_after(x : T, a : *Item) : *Item := \n        checkFreeList() //make sure freeList is non empty\n        b := freeList.first() // obtain an item b to hold x\n        move_after(b, a) // insert b after a\n        b-&gt;e := x // set the data item value of b to x\n        return b\n\n    // Manipulating whole lists\n    Procedure concat(L : List) :=\n        splice(L.first(), L.last(), last()) //move whole of L after last element of this list\n\n    Procedure clear()\n        freeList.concat(this) //after this operation from from first to last element of this\n                              // list are concatenated to the freeList, leaving only the \n                              // dummy element in this list.\n\n    Fuction get(i )\n\n    \n\n    \n\nSplicing\nThe code for splicing of the List class:\n/* Splice is an all-purpose tool to cut out parts from a list\n    Cut out (a, ... b) form this list and insert after t */\nProcedure splice(a, b, t : *Item) := \n    assert (\n        b is not before a \n        and \n        t not between a and b\n    )\n    // Cut out (a, ... , b)\n    a-&gt;prev-&gt;next := b-&gt;next\n    b-&gt;next-&gt;prev := a-&gt;prev\n\n    // insert (a, ... b) after t\n    t-&gt;next-&gt;prev := b\n    b-&gt;next := t-&gt;next\n    t-&gt;next := a\n    a-&gt;prev := t\n\nDlist cut-out \\((a,...,b)\\) (see Figure 2.1):\n\n\n\n\n\n\n\nFigure 2.1: cutout\n\n\n\n\nDlist insert \\((a,...,b)\\) after \\(t\\) (see Figure 2.2):\n\n\n\n\n\n\n\nFigure 2.2: insert\n\n\n\n\n\nSpeicherverwaltung ./.FreeList\nMethods (?):\n\nNiavely: allocate memory for each new element, deallocate memory after deleting each element:\n\nadvantage: simplicity\ndisadvantage: requires a good implementation of memory management: potentially very slow\n\n“global” freeList (e.g. static member in C++)\n\ndoubly linked list of all not used elements\ntransfer ‘deleted’ elements in freeList.\ncheckFreeList allocates, in case the list is empty\n\n\nReal implementations: * naiv but with well implemented, efficient memory management * refined Free List Approach (class-agnostic, release) * implementation-specific.\n\n\nDeleting Elements\nDeleting elements realised by moving them to the global freeList:\nProcedure remove(a: *Item) :=\n    move_after(a, freeList.dummy) // item a is now a 'free' item. \n\nProcedure pop_front() :=\n    remove(first())\n\nProcedure pop_back() :=\n    remove(last())\n\n\nInserting Elements\nInserting elements into a list \\(l\\) also utilizes freeList, by fetching its first element an moving it into \\(l\\).\nFunction insert_after(x : T, a : *Item) : *Item := \n    checkFreeList() //make sure freeList is non empty\n    b := freeList.first() // obtain an item b to hold x\n    move_after(b, a) // insert b after a\n    b-&gt;e := x // set the data item value of b to x\n    return b\n\nFunction insert_before(x : T, b : *Item) : *Item :=\n    return insert_after(x, b-&gt;prev)\n\nProcedure push_front(x : T) :=\n    insert_after(x, dummy)\n\nProcedure push_back(x : T) :=\n    insert_after(x, last())\n\n\nManipulating whole Lists\n// Manipulating whole lists\nProcedure concat(L : List) :=\n    splice(L.first(), L.last(), last()) //move whole of L after last element of this list\n\nProcedure clear()\n    freeList.concat(this) //after this operation from from first to last element of this\n                            // list are concatenated to the freeList, leaving only the \n                            // dummy element in this list.\nThis operations require constant time - indeendent of the list size!",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "03/02-arrays.html",
    "href": "03/02-arrays.html",
    "title": "3  Arrays",
    "section": "",
    "text": "3.1 Bounded Arrays\nBounded arrays have fixed size and are an efficient data structure.",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Arrays</span>"
    ]
  },
  {
    "objectID": "03/02-arrays.html#bounded-arrays",
    "href": "03/02-arrays.html#bounded-arrays",
    "title": "3  Arrays",
    "section": "",
    "text": "Size must be known during compile time and is fixed.\nIts memory location in the stack allows many compiler optimizations.",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Arrays</span>"
    ]
  },
  {
    "objectID": "03/02-arrays.html#unbounded-arrays",
    "href": "03/02-arrays.html#unbounded-arrays",
    "title": "3  Arrays",
    "section": "3.2 Unbounded Arrays",
    "text": "3.2 Unbounded Arrays\nThe size of an unbounded array can dynamically change during run-time. From the user POV it provides the same behaviour as a linked list.\nIt allows the operations:\n\npushBack(e: T): insert an element at the end of the array\npopBack(e: T): remove an element at the end of the array\n\n\nMemory Management\n\nallocate(n): request a \\(n\\) contigious blocks of memory words and returns the address value of the first block. This we have the memory blocks:\n\n\n\narray memory allocation\n\n\nwhere ptr + i addresses are determined by pointer arithmetic.\ndispose(ptr) marks the memory address value held in ptr as free, effectively deleting the object held there.\n\nIn general, the allocated memory can’t grow dynamically during life time, since the immediate memory block after the last one might get unpredictably occupied \\(\\Rightarrow\\) If we need a new memory block of size \\(n' &gt; n\\), we must allocate a new block, copy the old block contents, and finally free it.\n\n\nImplementation\nFirst we consider a slow variant:\nClass UArraySlow&lt;T&gt;:=\n  c := 0 : Nat // capacity\n  b : Array[0..c-1]&lt;T&gt; // the array itself\n\n  pushBack(el : T) : void :=\n    // c++\n    // allocate new array on heap with new capacity\n    // copy elements over from the old array\n    // insert el at the last location\n  \n  popBack() : void := \n    // analagous\nProblem: \\(n\\) pushBack operations require \\(1 + \\dots + n \\in \\mathcal{O}(n^2)\\) time \\(\\Rightarrow\\) slow.\nSolution:\n\nUnbounded Arrays with Extra Memory\nIdea: Request more memory than initial capacity. Reallocate memory only when array gets full or too empty:\nAlgorithm design principle: make common case fast.\nClass UArray&lt;T&gt; := \n  c := 1 : Nat // capacity\n  n := 0 : Nat // number of elements in the array\n\n  //invariant n &lt;= c &lt; k*n || (n == 0 && c &lt; 2)\n  b : Array[0..c-1]&lt;T&gt;\n\n  // Array access\n  Operator [i : Nat] : T := \n    assert(0 &lt;= i &lt; n)\n    return b[i]\n\n  // accessor method for n\n  Function size() : Nat := return n\n\n  Procedure pushBack(e : T) := \n    if n == c :\n      reallocate(2*n) // see definition below\n    b[n] := e\n    n++\n\n  // reallocates a new memory with a given capacity c_new\n  Procedure reallocate(c_new : Nat) := \n    c := c_new \n    b_new := new Array[0..c_new - 1]&lt;T&gt;\n    //copy elements over to new array\n    for (i = 1 to n - 1) :\n      b_new[i] := b[i]\n    dispose(b)\n    b := b_new \n\n  Procedure popBack() :=\n    // don't do anything for empty arrays\n    assert n &gt; 0\n    n--\n    if 4*n &lt;= c && n &gt; 0 :\n      reallocate(2*n)",
    "crumbs": [
      "Data Structures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Arrays</span>"
    ]
  }
]