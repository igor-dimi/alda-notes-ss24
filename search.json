[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures Notes - SoSe 24",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "02-intro/02-analysis.html#reccurence-relations",
    "href": "02-intro/02-analysis.html#reccurence-relations",
    "title": "1  Program Run-time Analysis",
    "section": "1.1 Reccurence Relations",
    "text": "1.1 Reccurence Relations\nConsider a very simple reccurence relation:\n\\[\n    T(n) :=\n    \\begin{cases}\n        1               & n = 1 \\\\\n        n + T(n - 1),   & n &gt; 1\n    \\end{cases}\n\\]\nWith mathematical induction we can formally show that \\(T(n)\\) is quadratic. But there is a simpler & more intuitive way:\n\\[\\begin{align*}\n    T(n) &= n + T(n - 1)            \\tag{Def $T(\\cdot)$} \\\\\n         &= n + n - 1 + T(n - 2)  \\\\\n         &= \\dots \\tag{Repeat $n - 2$ times}\\\\\n         &= n + n - 1 + \\dots + T(1) \\\\\n         &= n + n - 1 + \\dots + 1 \\tag{Def $T(1)$} \\\\\n         &= \\frac{n(n + 1)}{2} \\tag{Gauss}\\\\\n         &\\in \\mathcal{O}(n^2)\n\\end{align*}\\]\nThis method can be applied to the more complex divide-and-conquer reccurence relation from the lecture:\n\\[\n    R(n) :=\n    \\begin{cases}\n        a, &n = 1 \\\\\n        c\\dot n + d\\cdot R(\\frac{n}{b}), &n &gt; 1\n    \\end{cases}\n\\]\nApplying the above method we expand \\(R(\\cdot)\\) repetitively according to its definition until we reach the base case, rearranging terms when necessary:\n\\[\\begin{align*}\n    R(n) &= c\\cdot n + d\\cdot R(\\frac{n}{b}) \\tag{Def $R(\\cdot)$} \\\\\n         &= c\\cdot n + d\\bigl(c\\frac{n}{b} + d\\cdot R(\\frac{n}{b^2})\\bigr)  \\\\\n         &= c\\cdot n + d\\Bigl(c\\frac{n}{b} + d\\cdot \\bigl(c\\cdot \\frac{n}{b^2} + d\\cdot R(\\frac{n}{b^2})\\bigr)\\Bigr)  \\\\\n         &= c\\cdot n + d\\cdot c\\frac{n}{b} + d^2c\\frac{n}{b^2} + d^3\\cdot R(\\frac{n}{b^3}) \\tag{Rearrange} \\\\\n         &= c\\cdot n \\left(1 + \\frac{d}{b} + \\frac{d^2}{b^2}\\right) + d^3\\cdot R(\\frac{n}{b^3}) \\\\\n         &= \\dots \\tag{Repeat $k$-times} \\\\\n         &= c\\cdot n\\left(1 + \\frac{d}{b} + \\dots + \\frac{d^{k - 1}}{b^{k - 1}}\\right) + d^k \\cdot R(\\frac{n}{b^k}) \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + d^k \\cdot R(\\frac{n}{b^k}) \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + d^k \\cdot R(1) \\tag{Ass $\\frac{n}{b^k} = 1$} \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + a\\cdot d^k \\tag{Def $R(1)$}\n\\end{align*}\\]\nSee lecture slides for the complexity analysis of final expression."
  },
  {
    "objectID": "03/01-lists.html#sequences-as-arrays-and-lists",
    "href": "03/01-lists.html#sequences-as-arrays-and-lists",
    "title": "2  Lists",
    "section": "2.1 Sequences as Arrays and Lists",
    "text": "2.1 Sequences as Arrays and Lists\nMany terms for same thing: sequence, field, list, stack, string, file… Yes, files are simply sequences of bytes!\nthree views on lists:\n\nabstract: \\((2, 3, 5, 7)\\)\nfunctionality: stack, queue, etc… What operations does it support?\nrepresentation: How is the list represented in a given programming model/language/paradigm?"
  },
  {
    "objectID": "03/01-lists.html#applications-of-lists",
    "href": "03/01-lists.html#applications-of-lists",
    "title": "2  Lists",
    "section": "2.2 Applications of Lists",
    "text": "2.2 Applications of Lists\n\nStoring and processing any kinds of data\nConcrete representation of abstract data types such as: set, graph, etc…"
  },
  {
    "objectID": "03/01-lists.html#linked-and-doubly-linked-lists",
    "href": "03/01-lists.html#linked-and-doubly-linked-lists",
    "title": "2  Lists",
    "section": "2.3 Linked and Doubly Linked Lists",
    "text": "2.3 Linked and Doubly Linked Lists\n\n\n\n\nsimply linked\ndoubly linked\n\n\n\n\nlecture\nSList\nList\n\n\nc++\nstd::forward_list\nstd::list\n\n\n\nDoubly linked lists are usually simpler and require “only” double the space at most. Therefore their use is more widespread.\n\nList Items\nClass Item of T :=\n    e: T\n    next: *Item //Pointer to Item\n    prev: *Item //Pointer to Item\n    invariant next-&gt;prev = this = prev-&gt;next\n\nProblem: * predeccessor of first list element? * successor of last list element?\nSolution: Dummy Item with an empty data field as follows:\n\nAdvatanges of this solution:\n\nInvariant is always satisfied\nExceptions are avoided, thus making the coding more:\n\nsimple\nreadable\nfaster\nelegant\n\n\nDisadvantages: a little more storage space.\n\n\nThe List Class\nClass List of T :=\n    dummy := (\n        Null : T\n        &dummy : *T // initially list is empty, therefore next points to the dummy itself\n        &dummy : *T // initially list is empty, therefore prev points to the dummy itself\n    ) : Item\n\n    // returns the address of the dummy, which represents the head of the list\n    Function head() : *Item :=\n        return address of dummy\n    \n    // simple access functions\n    // returns true iff list empty\n    Function is_empty() : Bool := \n        return dummy.next == dummy \n\n    // returns pointer to first Item of the list, given list is not empty\n    Function first() : *Item :=\n        assert (not is_empty())\n        return dummy.next\n    \n    // returns pointer to last Item of the list, given list is not empty\n    Function last() : *Item :=\n        assert (not is_empty())\n        return dummy.last\n\n    /* Splice is an all-purpose tool to cut out parts from a list\n       Cut out (a, ... b) form this list and insert after t */\n    Procedure splice(a, b, t : *Item) := \n        assert (\n            b is not before a \n            and \n            t not between a and b\n        )\n        // Cut out (a, ... , b)\n        a-&gt;prev-&gt;next := b-&gt;next\n        b-&gt;next-&gt;prev := a-&gt;prev\n\n        // insert (a, ... b) after t\n        t-&gt;next-&gt;prev := b\n        b-&gt;next := t-&gt;next\n        t-&gt;next := a\n        a-&gt;prev := t\n\nDlist cut-out \\((a,...,b)\\):\n\n\n\nDlist insert \\((a,...,b)\\) after \\(t\\):"
  }
]