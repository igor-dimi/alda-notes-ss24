[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures Notes - SoSe 24",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "02-intro/02-analysis.html#reccurence-relations",
    "href": "02-intro/02-analysis.html#reccurence-relations",
    "title": "1  Program Run-time Analysis",
    "section": "1.1 Reccurence Relations",
    "text": "1.1 Reccurence Relations\nConsider a very simple reccurence relation:\n\\[\n    T(n) :=\n    \\begin{cases}\n        1               & n = 1 \\\\\n        n + T(n - 1),   & n &gt; 1\n    \\end{cases}\n\\]\nWith mathematical induction we can formally show that \\(T(n)\\) is quadratic. But there is a simpler & more intuitive way:\n\\[\\begin{align*}\n    T(n) &= n + T(n - 1)            \\tag{Def $T(\\cdot)$} \\\\\n         &= n + n - 1 + T(n - 2)  \\\\\n         &= \\dots \\tag{Repeat $n - 2$ times}\\\\\n         &= n + n - 1 + \\dots + T(1) \\\\\n         &= n + n - 1 + \\dots + 1 \\tag{Def $T(1)$} \\\\\n         &= \\frac{n(n + 1)}{2} \\tag{Gauss}\\\\\n         &\\in \\mathcal{O}(n^2)\n\\end{align*}\\]\nThis method can be applied to the more complex divide-and-conquer reccurence relation from the lecture:\n\\[\n    R(n) :=\n    \\begin{cases}\n        a, &n = 1 \\\\\n        c\\dot n + d\\cdot R(\\frac{n}{b}), &n &gt; 1\n    \\end{cases}\n\\]\nApplying the above method we expand \\(R(\\cdot)\\) repetitively according to its definition until we reach the base case, rearranging terms when necessary:\n\\[\\begin{align*}\n    R(n) &= c\\cdot n + d\\cdot R(\\frac{n}{b}) \\tag{Def $R(\\cdot)$} \\\\\n         &= c\\cdot n + d\\bigl(c\\frac{n}{b} + d\\cdot R(\\frac{n}{b^2})\\bigr)  \\\\\n         &= c\\cdot n + d\\Bigl(c\\frac{n}{b} + d\\cdot \\bigl(c\\cdot \\frac{n}{b^2} + d\\cdot R(\\frac{n}{b^2})\\bigr)\\Bigr)  \\\\\n         &= c\\cdot n + d\\cdot c\\frac{n}{b} + d^2c\\frac{n}{b^2} + d^3\\cdot R(\\frac{n}{b^3}) \\tag{Rearrange} \\\\\n         &= c\\cdot n \\left(1 + \\frac{d}{b} + \\frac{d^2}{b^2}\\right) + d^3\\cdot R(\\frac{n}{b^3}) \\\\\n         &= \\dots \\tag{Repeat $k$-times} \\\\\n         &= c\\cdot n\\left(1 + \\frac{d}{b} + \\dots + \\frac{d^{k - 1}}{b^{k - 1}}\\right) + d^k \\cdot R(\\frac{n}{b^k}) \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + d^k \\cdot R(\\frac{n}{b^k}) \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + d^k \\cdot R(1) \\tag{Ass $\\frac{n}{b^k} = 1$} \\\\\n         &= c\\cdot n \\sum_{i = 0}^{k - 1}\\left(\\frac{d}{b}\\right)^i + a\\cdot d^k \\tag{Def $R(1)$}\n\\end{align*}\\]\nSee lecture slides for the complexity analysis of final expression."
  },
  {
    "objectID": "03/01-lists.html#sequences-as-arrays-and-lists",
    "href": "03/01-lists.html#sequences-as-arrays-and-lists",
    "title": "2  Lists",
    "section": "2.1 Sequences as Arrays and Lists",
    "text": "2.1 Sequences as Arrays and Lists\nMany terms for same thing: sequence, field, list, stack, string, file… Yes, files are simply sequences of bytes!\nthree views on lists:\n\nabstract: \\((2, 3, 5, 7)\\)\nfunctionality: stack, queue, etc… What operations does it support?\nrepresentation: How is the list represented in a given programming model/language/paradigm?"
  },
  {
    "objectID": "03/01-lists.html#applications-of-lists",
    "href": "03/01-lists.html#applications-of-lists",
    "title": "2  Lists",
    "section": "2.2 Applications of Lists",
    "text": "2.2 Applications of Lists\n\nStoring and processing any kinds of data\nConcrete representation of abstract data types such as: set, graph, etc…"
  },
  {
    "objectID": "03/01-lists.html#linked-and-doubly-linked-lists",
    "href": "03/01-lists.html#linked-and-doubly-linked-lists",
    "title": "2  Lists",
    "section": "2.3 Linked and Doubly Linked Lists",
    "text": "2.3 Linked and Doubly Linked Lists\n\n\n\n\nsimply linked\ndoubly linked\n\n\n\n\nlecture\nSList\nList\n\n\nc++\nstd::forward_list\nstd::list\n\n\n\nDoubly linked lists are usually simpler and require “only” double the space at most. Therefore their use is more widespread.\n\nList Items\nClass Item of T :=\n    e: T //Data item of type T\n    next: *Item //Pointer to Item\n    prev: *Item //Pointer to Item\n    invariant next-&gt;prev = this = prev-&gt;next\n\nProblem: * predeccessor of first list element? * successor of last list element?\nSolution: Dummy Item with an empty data field as follows:\n\nAdvatanges of this solution:\n\nInvariant is always satisfied\nExceptions are avoided, thus making the coding more:\n\nsimple\nreadable\nfaster\nelegant\n\n\nDisadvantages: a little more storage space.\n\n\nThe List Class\nClass List of T :=\n    dummy := (\n        Null : T\n        &dummy : *T // initially list is empty, therefore next points to the dummy itself\n        &dummy : *T // initially list is empty, therefore prev points to the dummy itself\n    ) : Item\n\n    // returns the address of the dummy, which represents the head of the list\n    Function head() : *Item :=\n        return address of dummy\n    \n    // simple access functions\n    // returns true iff list empty\n    Function is_empty() : Bool := \n        return dummy.next == dummy \n\n    // returns pointer to first Item of the list, given list is not empty\n    Function first() : *Item :=\n        assert (not is_empty())\n        return dummy.next\n    \n    // returns pointer to last Item of the list, given list is not empty\n    Function last() : *Item :=\n        assert (not is_empty())\n        return dummy.prev\n\n    /* Splice is an all-purpose tool to cut out parts from a list\n       Cut out (a, ... b) form this list and insert after t */\n    Procedure splice(a, b, t : *Item) := \n        assert (\n            b is not before a \n            and \n            t not between a and b\n        )\n        // Cut out (a, ... , b)\n        a-&gt;prev-&gt;next := b-&gt;next\n        b-&gt;next-&gt;prev := a-&gt;prev\n\n        // insert (a, ... b) after t\n        t-&gt;next-&gt;prev := b\n        b-&gt;next := t-&gt;next\n        t-&gt;next := a\n        a-&gt;prev := t\n\n    \n    // Moving items by utilising splice\n    //Move item a after item b\n    Procedure move_after(a, b: *Item) := \n        splice(a, a, b)\n    \n    // Move item a to the front of the list\n    Procedure move_to_front(a: *Item) := \n        move_after(a, dummy)\n\n    Procedure move_to_back(a: *Item) :=\n        move_after(b, last())\n\n    // Deleting items by moving them to a global freeList\n    // remove item a\n    Procedure remove(a: *Item) :=\n        move_after(b, freeList.dummy)\n    \n    // remove first item\n    Procedure pop_front() :=\n        remove(first())\n\n    //remove last item\n    Procedure pop_back() :=\n        remove(last())\n\n    // Inserting Elements\n    // Insert an item with value x after item a\n    Function insert_after(x : T, a : *Item) : *Item := \n        checkFreeList() //make sure freeList is non empty\n        b := freeList.first() // obtain an item b to hold x\n        move_after(b, a) // insert b after a\n        b-&gt;e := x // set the data item value of b to x\n        return b\n\n    // Manipulating whole lists\n    Procedure concat(L : List) :=\n        splice(L.first(), L.last(), last()) //move whole of L after last element of this list\n\n    Procedure clear()\n        freeList.concat(this) //after this operation from from first to last element of this\n                              // list are concatenated to the freeList, leaving only the \n                              // dummy element in this list.\n\n    Fuction get(i )\n\n    \n\n    \n\nSplicing\nThe code for splicing of the List class:\n/* Splice is an all-purpose tool to cut out parts from a list\n    Cut out (a, ... b) form this list and insert after t */\nProcedure splice(a, b, t : *Item) := \n    assert (\n        b is not before a \n        and \n        t not between a and b\n    )\n    // Cut out (a, ... , b)\n    a-&gt;prev-&gt;next := b-&gt;next\n    b-&gt;next-&gt;prev := a-&gt;prev\n\n    // insert (a, ... b) after t\n    t-&gt;next-&gt;prev := b\n    b-&gt;next := t-&gt;next\n    t-&gt;next := a\n    a-&gt;prev := t\n\nDlist cut-out \\((a,...,b)\\) (see Figure 2.1):\n\n\n\n\nFigure 2.1: cutout\n\n\n\nDlist insert \\((a,...,b)\\) after \\(t\\) (see Figure 2.2):\n\n\n\n\nFigure 2.2: insert\n\n\n\n\nSpeicherverwaltung ./.FreeList\nMethods (?):\n\nNiavely: allocate memory for each new element, deallocate memory after deleting each element:\n\nadvantage: simplicity\ndisadvantage: requires a good implementation of memory management: potentially very slow\n\n“global” freeList (e.g. static member in C++)\n\ndoubly linked list of all not used elements\ntransfer ‘deleted’ elements in freeList.\ncheckFreeList allocates, in case the list is empty\n\n\nReal implementations: * naiv but with well implemented, efficient memory management * refined Free List Approach (class-agnostic, release) * implementation-specific.\n\n\nDeleting Elements\nDeleting elements realised by moving them to the global freeList:\nProcedure remove(a: *Item) :=\n    move_after(a, freeList.dummy) // item a is now a 'free' item. \n\nProcedure pop_front() :=\n    remove(first())\n\nProcedure pop_back() :=\n    remove(last())\n\n\nInserting Elements\nInserting elements into a list \\(l\\) also utilizes freeList, by fetching its first element an moving it into \\(l\\).\nFunction insert_after(x : T, a : *Item) : *Item := \n    checkFreeList() //make sure freeList is non empty\n    b := freeList.first() // obtain an item b to hold x\n    move_after(b, a) // insert b after a\n    b-&gt;e := x // set the data item value of b to x\n    return b\n\nFunction insert_before(x : T, b : *Item) : *Item :=\n    return insert_after(x, b-&gt;prev)\n\nProcedure push_front(x : T) :=\n    insert_after(x, dummy)\n\nProcedure push_back(x : T) :=\n    insert_after(x, last())\n\n\nManipulating whole Lists\n// Manipulating whole lists\nProcedure concat(L : List) :=\n    splice(L.first(), L.last(), last()) //move whole of L after last element of this list\n\nProcedure clear()\n    freeList.concat(this) //after this operation from from first to last element of this\n                            // list are concatenated to the freeList, leaving only the \n                            // dummy element in this list.\nThis operations require constant time - indeendent of the list size!"
  }
]